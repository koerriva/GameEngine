// This file was automatically generated using Shader Sourcerer 1.0

shaderSources["atmosphere.frag"] = 
  "uniform vec3  atmosphereColor;\n"
  "varying float alpha;\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  gl_FragColor = vec4(atmosphereColor, alpha);\n"
  "}\n"
  "\n";

SHADER_FILES(ATMOSPHERE, "atmosphere.vert", "atmosphere.frag")

shaderSources["atmosphere.vert"] = 
  "uniform vec3  lightDir;\n"
  "uniform float planetRadius;\n"
  "uniform float atmosphereRadius;\n"
  "uniform vec3  camPos;\n"
  "uniform float camHeight;\n"
  "varying float alpha;\n"
  "\n"
  "// www.cs.umbc.edu/~alark1/cmsc435/lectures/RayCasting4.pdf\n"
  "float getFirstRaySphereIntersection(vec3 rayOrigin, vec3 rayDir, float radius)\n"
  "{\n"
  "  float b = 2.0 * dot(rayOrigin, rayDir);\n"
  "  float c = dot(rayOrigin, rayOrigin) - radius * radius;\n"
  "  float discriminant = sqrt(max(0.0, b * b - 4.0 * c));\n"
  "  float t0 = -0.5 * b - 0.5 * discriminant;\n"
  "  //float t1 = -0.5 * b + 0.5 * discriminant;\n"
  "  return t0;\n"
  "}\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  // Ray end is vertex position\n"
  "  vec3 rayEnd = gl_Vertex.xyz * atmosphereRadius;\n"
  "  \n"
  "  // Ray direction from camera position to ray end\n"
  "  vec3 rayDir = normalize(rayEnd - camPos);\n"
  "  \n"
  "  // Ray start is camera position if inside atmosphere, else first intersection\n"
  "  vec3 rayStart = camPos;\n"
  "  if (camHeight > atmosphereRadius)\n"
  "    rayStart += rayDir * getFirstRaySphereIntersection(camPos, rayDir, atmosphereRadius);\n"
  "  \n"
  "  // Distance within atmosphere\n"
  "  float rayLength = distance(rayEnd, rayStart);\n"
  "  float atmosphereHeight = atmosphereRadius - planetRadius;\n"
  "  alpha = rayLength / atmosphereRadius;\n"
  "  //alpha *= alpha;\n"
  "  \n"
  "  #define STEPS 5\n"
  "  alpha = 0.0;\n"
  "  float stepSize = rayLength / float(STEPS);\n"
  "  for (int i = 0; i < STEPS; i++)\n"
  "  {\n"
  "    vec3 rayStepPos = rayStart + float(i) * stepSize * rayDir;\n"
  "    float rayStepPosHeight = length(rayStepPos);\n"
  "    vec3 rayStepDir = rayStepPos / rayStepPosHeight;\n"
  "    float density = 1.0 - (rayStepPosHeight - planetRadius) / atmosphereHeight;\n"
  "    density -= 0.2;\n"
  "    float light = max(0.0, 0.2 + dot(rayStepDir, lightDir));\n"
  "    alpha += light * density;\n"
  "  }\n"
  "  alpha /= float(STEPS);\n"
  "  \n"
  "  // Enhance the alpha value\n"
  "  alpha *= 1.6;\n"
  "  \n"
  "  gl_Position = gl_ModelViewProjectionMatrix * vec4(rayEnd, 1.0);\n"
  "}\n"
  "\n";

shaderSources["axis.frag"] = 
  "varying vec3 normal;\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  float light = max(0.0, normal.z);\n"
  "  gl_FragColor = vec4(light, light, light, 1.0);\n"
  "}\n"
  "\n";

SHADER_FILES(AXIS, "axis.vert", "axis.frag")

shaderSources["axis.vert"] = 
  "varying vec3 normal;\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  normal = normalize(gl_NormalMatrix * gl_Normal);\n"
  "  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
  "}\n"
  "\n";

shaderSources["clouds.frag"] = 
  "uniform sampler2D cloudTex;\n"
  "uniform vec3      cloudTexWeights;\n"
  "varying float     light;\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  // Get the three cloud textures samples (one per texture channel)\n"
  "  vec3 texSample = texture2D(cloudTex, gl_TexCoord[0].st).rgb;\n"
  "  \n"
  "  // Sum the weighted textures samples\n"
  "  float alpha = dot(cloudTexWeights, texSample);\n"
  "  \n"
  "  // Enhance the alpha value\n"
  "  alpha = smoothstep(0.3, 0.7, alpha);\n"
  "  \n"
  "  // Use light and alpha to set the final color\n"
  "  gl_FragColor = vec4(light, light, light, alpha);\n"
  "}\n"
  "\n";

SHADER_FILES(CLOUDS, "clouds.vert", "clouds.frag")

shaderSources["clouds.vert"] = 
  "uniform vec3  lightDir;\n"
  "uniform float cloudLayerRadius;\n"
  "varying float light;\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  // Set texture coordinates\n"
  "  gl_TexCoord[0].st = gl_MultiTexCoord0.st;\n"
  "  \n"
  "  // The normal is simply xyz of the untransformed vertex position\n"
  "  vec3 normal = gl_Vertex.xyz;\n"
  "  \n"
  "  // Calculate incoming light\n"
  "  light = max(0.0, dot(lightDir, normal) + 0.4);\n"
  "  \n"
  "  // Scale by radius to get the true vertex position\n"
  "  vec3 vert = normal * cloudLayerRadius;\n"
  "  \n"
  "  gl_Position = gl_ModelViewProjectionMatrix * vec4(vert, 1.0);\n"
  "}\n"
  "\n";

shaderSources["cloud_texture.frag"] = 
  "#pragma include perlin.frag\n"
  "\n"
  "uniform int   octaves;\n"
  "uniform float cloudCover;\n"
  "uniform float cloudSharpness;\n"
  "uniform float freq0;\n"
  "\n"
  "#define PI 3.14159265\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  // Calculate cartesian coordinates (direction, not position)\n"
  "  float theta = gl_TexCoord[0].s * PI * 2.0;\n"
  "  float phi   = gl_TexCoord[0].t * PI;\n"
  "  vec3  dir0  = vec3(cos(theta) * sin(phi), sin(theta) * sin(phi), cos(phi));\n"
  "  vec3  dir1  = vec3( dir0.x, dir0.z, -dir0.y);\n"
  "  vec3  dir2  = vec3(-dir0.x, dir0.y,  dir0.z);\n"
  "  \n"
  "  // Make some noise (three channels; produces three different cloud textures)\n"
  "  vec3  nSum    = vec3(0.0, 0.0, 0.0);\n"
  "  vec3  freq    = vec3(freq0, freq0, freq0);\n"
  "  vec3  lac     = vec3(2.1, 2.2, 2.3);\n"
  "  float weight  = 1.0;\n"
  "  float sumMax  = 0.0;\n"
  "  for (int i = 0; i < octaves; i++)\n"
  "  {\n"
  "    // Add noise value\n"
  "    nSum.x  += weight * perlin(freq.x * dir0);\n"
  "    nSum.y  += weight * perlin(freq.y * dir1);\n"
  "    nSum.z  += weight * perlin(freq.z * dir2);\n"
  "    \n"
  "    // The sum of all weights is used to normalize the results\n"
  "    sumMax  += weight;\n"
  "    \n"
  "    // Update variables\n"
  "    weight  *= 0.5;\n"
  "    freq    *= lac;\n"
  "  }\n"
  "  nSum /= sumMax;           // [-1,1]\n"
  "  nSum = 0.5 + 0.5 * nSum;  // [ 0,1]\n"
  "  \n"
  "  // http://freespace.virgin.net/hugo.elias/models/m_clouds.htm\n"
  "  vec3 c   = max(nSum - cloudCover, 0.0);\n"
  "  vec3 val = 1.0 - pow(vec3(cloudSharpness), c);\n"
  "  \n"
  "  //gl_FragColor = vec4(1.0, 1.0, 1.0, val);\n"
  "  gl_FragColor = vec4(val, 1.0);\n"
  "}\n"
  "\n";

SHADER_FILES(CLOUD_TEXTURE, "cloud_texture.vert", "cloud_texture.frag")

shaderSources["cloud_texture.vert"] = 
  "void main(void)\n"
  "{\n"
  "  gl_TexCoord[0].st = 0.5 + 0.5 * gl_Vertex.xy;\n"
  "	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
  "}\n"
  "\n";

shaderSources["patch_normalmap_heightmap.frag"] = 
  "uniform sampler2D positionmap;\n"
  "uniform float texelSize;\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  // Sample positions\n"
  "  vec3 posX0Y0 = texture2D(positionmap, gl_TexCoord[0].st).rgb;\n"
  "  vec3 posXMY0 = texture2D(positionmap, gl_TexCoord[0].st - vec2(texelSize, 0.0)).rgb;\n"
  "  vec3 posXPY0 = texture2D(positionmap, gl_TexCoord[0].st + vec2(texelSize, 0.0)).rgb;\n"
  "  vec3 posX0YM = texture2D(positionmap, gl_TexCoord[0].st - vec2(0.0, texelSize)).rgb;\n"
  "  vec3 posX0YP = texture2D(positionmap, gl_TexCoord[0].st + vec2(0.0, texelSize)).rgb;\n"
  "  \n"
  "  // Edges connecting the samples\n"
  "  vec3 edgeXM = posXMY0 - posX0Y0;\n"
  "  vec3 edgeXP = posXPY0 - posX0Y0;\n"
  "  vec3 edgeYM = posX0YM - posX0Y0;\n"
  "  vec3 edgeYP = posX0YP - posX0Y0;\n"
  "  \n"
  "  // Using only one of these normals is faster but not as accurate\n"
  "  vec3 normalM = cross(edgeXM, edgeYM);\n"
  "  vec3 normalP = cross(edgeXP, edgeYP);\n"
  "  \n"
  "  // Normalize the sum of both normals (averaging happens automatically)\n"
  "  vec3 normal = normalize(normalM + normalP);\n"
  "  gl_FragData[0] = 0.5 + 0.5 * vec4(normal, 1.0);\n"
  "  gl_FragData[1] = vec4(texture2D(positionmap, gl_TexCoord[0].st).a);\n"
  "}\n"
  "\n";

SHADER_FILES(PATCH_NORMALMAP_HEIGHTMAP, "patch_normalmap_heightmap.vert", "patch_normalmap_heightmap.frag")

shaderSources["patch_normalmap_heightmap.vert"] = 
  "void main(void)\n"
  "{\n"
  "  gl_TexCoord[0].st = gl_MultiTexCoord0.st;\n"
  "	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
  "}\n"
  "\n";

shaderSources["patch_positionmap.frag"] = 
  "#pragma include perlin.frag\n"
  "\n"
  "uniform float heightScale;\n"
  "uniform int   octaves;\n"
  "uniform float gain;\n"
  "uniform float lacunarity;\n"
  "uniform float offset;\n"
  "uniform float h;\n"
  "varying vec3  cubePosition;\n"
  "\n"
  "// http://mathproofs.blogspot.com/2005/07/mapping-cube-to-sphere.html\n"
  "vec3 cubeToSphere(vec3 pt)\n"
  "{\n"
  "  vec3 ptSq = pt * pt;\n"
  "  return pt.xyz * sqrt(max(1.0 - (ptSq.yzx + ptSq.zxy) * 0.5 + ptSq.yzx * ptSq.zxy * 0.3333333, 0.0));\n"
  "}\n"
  "\n"
  "float ridgedMultifractal(vec3 dir)\n"
  "{\n"
  "  float frequency = lacunarity, signal, weight;\n"
  "  \n"
  "  // Get the base signal (absolute value to create the ridges; square for sharper ridges)\n"
  "  signal = offset - abs(perlin(dir));\n"
  "  signal *= signal;\n"
  "  float result = signal;\n"
  "  \n"
  "  float exponentArraySum = 1.0;\n"
  "  for (int i = 1; i < octaves; i++)\n"
  "  {\n"
  "    // This could be precalculated\n"
  "    float exponentValue = pow(frequency, -h);\n"
  "    exponentArraySum += exponentValue;\n"
  "    frequency *= lacunarity;\n"
  "    \n"
  "    dir *= lacunarity;\n"
  "    weight = clamp(signal * gain, 0.0, 1.0);\n"
  "    \n"
  "    // Get the next \"octave\" (only true octave if lacunarity = 2.0, right?)\n"
  "    signal = offset - abs(perlin(dir));\n"
  "    signal *= signal;\n"
  "    signal *= weight;\n"
  "    \n"
  "    result += signal * exponentValue;\n"
  "  }\n"
  "  \n"
  "  // Scale result to [0,1] (not true when offset != 1.0)\n"
  "  result /= exponentArraySum;\n"
  "  \n"
  "  return result;\n"
  "}\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  // Transform from cube [-1,1] to unit sphere\n"
  "  vec3 spherePosition = cubeToSphere(cubePosition);\n"
  "  \n"
  "  // Calculate height value\n"
  "  float rmf0 = ridgedMultifractal(spherePosition);\n"
  "  \n"
  "  // Scale and bias to match CPU implementation [-1,1]\n"
  "  float rmf1 = rmf0 * 2.0 - 1.0;\n"
  "  float height = 1.0 + rmf1 * heightScale;\n"
  "  //height *= radius;\n"
  "  \n"
  "  // RGBA with surface position (RGB) and RMF value (A)\n"
  "  gl_FragColor = vec4(spherePosition * height, rmf0);\n"
  "}\n"
  "\n";

SHADER_FILES(PATCH_POSITIONMAP, "patch_positionmap.vert", "patch_positionmap.frag")

shaderSources["patch_positionmap.vert"] = 
  "varying vec3 cubePosition;\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  // Vertex position on the cube [-1,1] is passed as texture coordinates\n"
  "  cubePosition = gl_MultiTexCoord0.xyz;\n"
  "  \n"
  "	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
  "}\n"
  "\n";

shaderSources["perlin.frag"] = 
  "uniform sampler2D permTex;\n"
  "\n"
  "#define TEXEL_FULL 0.003906250\n"
  "#define TEXEL_HALF 0.001953125\n"
  "#define FADE(t) ((t) * (t) * (t) * ((t) * ((t) * 6.0 - 15.0) + 10.0))\n"
  "\n"
  "float perlin(vec3 p)\n"
  "{\n"
  "  vec3 p0i = TEXEL_FULL * floor(p) + TEXEL_HALF;\n"
  "  vec3 p1i = p0i + TEXEL_FULL;\n"
  "  vec3 p0f = fract(p);\n"
  "  vec3 p1f = p0f - 1.0;\n"
  "  \n"
  "  vec3 u = FADE(p0f);\n"
  "  \n"
  "  // Could using a single RGBA texture for the four permutation table lookups increase performance?\n"
  "  float perm00 = texture2D(permTex, vec2(p0i.y, p0i.z)).a;\n"
  "  float perm10 = texture2D(permTex, vec2(p1i.y, p0i.z)).a;\n"
  "  float perm01 = texture2D(permTex, vec2(p0i.y, p1i.z)).a;\n"
  "  float perm11 = texture2D(permTex, vec2(p1i.y, p1i.z)).a;\n"
  "  \n"
  "  float a = dot(texture2D(permTex, vec2(p0i.x, perm00)).rgb * 4.0 - 1.0, vec3(p0f.x, p0f.y, p0f.z));\n"
  "  float b = dot(texture2D(permTex, vec2(p1i.x, perm00)).rgb * 4.0 - 1.0, vec3(p1f.x, p0f.y, p0f.z));\n"
  "  float c = dot(texture2D(permTex, vec2(p0i.x, perm10)).rgb * 4.0 - 1.0, vec3(p0f.x, p1f.y, p0f.z));\n"
  "  float d = dot(texture2D(permTex, vec2(p1i.x, perm10)).rgb * 4.0 - 1.0, vec3(p1f.x, p1f.y, p0f.z));\n"
  "  float e = dot(texture2D(permTex, vec2(p0i.x, perm01)).rgb * 4.0 - 1.0, vec3(p0f.x, p0f.y, p1f.z));\n"
  "  float f = dot(texture2D(permTex, vec2(p1i.x, perm01)).rgb * 4.0 - 1.0, vec3(p1f.x, p0f.y, p1f.z));\n"
  "  float g = dot(texture2D(permTex, vec2(p0i.x, perm11)).rgb * 4.0 - 1.0, vec3(p0f.x, p1f.y, p1f.z));\n"
  "  float h = dot(texture2D(permTex, vec2(p1i.x, perm11)).rgb * 4.0 - 1.0, vec3(p1f.x, p1f.y, p1f.z));\n"
  "  \n"
  "  vec4 lerpZ = mix(vec4(a, c, b, d), vec4(e, g, f, h), u.z);\n"
  "  vec2 lerpY = mix(lerpZ.xz, lerpZ.yw, u.y);\n"
  "  return mix(lerpY.x, lerpY.y, u.x);\n"
  "}\n"
  "\n";

shaderSources["planet.frag"] = 
  "uniform vec3      lightDir;\n"
  "uniform sampler2D colormap;\n"
  "uniform sampler2D heightmap;\n"
  "uniform sampler2D normalmap;\n"
  "uniform vec3      atmosphereColor;\n"
  "varying vec3      planetNormal;\n"
  "varying vec2      texCoord;\n"
  "varying float     dist;\n"
  "\n"
  "#define FOG_EXP 4.0\n"
  "#define FOG_MAX 0.25\n"
  "//#define AMBIENT 0.2\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  // Get terrain properties\n"
  "  float terrainHeight = texture2D(heightmap, texCoord).r;\n"
  "  float terrainSlope = 0.0;\n"
  "  vec3 normal = texture2D(normalmap, texCoord).rgb * 2.0 - 1.0;\n"
  "  \n"
  "  // Calculate incoming light\n"
  "  float light = max(0.0, dot(lightDir, normal)); // * (1.0 - AMBIENT) + AMBIENT;\n"
  "  \n"
  "  // Sphere self-shadowing (light shouldn't appear to pass through the planet)\n"
  "  float planetLight = max(0.0, dot(lightDir, planetNormal));\n"
  "  \n"
  "  // Color from colormap\n"
  "  vec3 color = texture2D(colormap, vec2(terrainHeight, terrainSlope)).rgb;\n"
  "  \n"
  "  // Fog value\n"
  "  float fogVal = max(0.0, (1.0 - exp(-FOG_EXP * dist)) * FOG_MAX);\n"
  "  \n"
  "  // Mixed color (color + fog)\n"
  "  vec3 colorFog = mix(color, atmosphereColor, fogVal);\n"
  "  \n"
  "  // Set final color\n"
  "  gl_FragColor = vec4(planetLight * colorFog, 1.0);\n"
  "  gl_FragColor = vec4(light * colorFog, 1.0);\n"
  "}\n"
  "\n";

SHADER_FILES(PLANET, "planet.vert", "planet.frag")

shaderSources["planet.vert"] = 
  "varying vec3  planetNormal;\n"
  "varying vec2  texCoord;\n"
  "varying float dist;\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  planetNormal = normalize(gl_Vertex.xyz);\n"
  "  texCoord = gl_MultiTexCoord0.st;\n"
  "  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
  "  dist = gl_Position.z;\n"
  "}\n"
  "\n";

shaderSources["planet_ring.frag"] = 
  "uniform sampler1D ringTex;\n"
  "uniform vec3      lightDir;\n"
  "varying vec3      normal;\n"
  "varying float     texCoord;\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  float light = dot(normal, lightDir);\n"
  "  light = clamp((light + 0.8) * 4.0, 0.0, 1.0);\n"
  "  vec4  color = texture1D(ringTex, texCoord);\n"
  "  gl_FragColor = vec4(light * color.rgb, color.a);\n"
  "}\n"
  "\n";

SHADER_FILES(PLANET_RING, "planet_ring.vert", "planet_ring.frag")

shaderSources["planet_ring.vert"] = 
  "varying vec3  normal;\n"
  "varying float texCoord;\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  texCoord = gl_MultiTexCoord0.t;\n"
  "  \n"
  "  // Normal rotated 90 degrees about the x axis (the way the disk is rendered)\n"
  "  normal = normalize(vec3(gl_Vertex.x, -gl_Vertex.z, gl_Vertex.y));\n"
  "  \n"
  "  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
  "}\n"
  "\n";

shaderSources["skybox_texture.frag"] = 
  "#pragma include perlin.frag\n"
  "\n"
  "#define OCTAVES 8\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  vec3 spherePos = normalize(gl_TexCoord[0].stp);\n"
  "  \n"
  "  // Make some noise\n"
  "  float sum     = 0.0;\n"
  "  float freq    = 4.0;\n"
  "  float weight  = 1.0;\n"
  "  for (int i = 0; i < OCTAVES; i++)\n"
  "  {\n"
  "    sum     += weight * perlin(freq * spherePos);\n"
  "    freq    *= 2.0;\n"
  "    weight  *= 0.5;\n"
  "  }\n"
  "  sum /= float(OCTAVES);\n"
  "  float val = 0.5 + 0.5 * sum;\n"
  "  val *= 1.8;\n"
  "  val = pow(val, 12.0);\n"
  "  //val = max(val, 0.4 * exp(2.0 * val) - 1.0);\n"
  "  //val = max(val * 1.5 - 0.2, 0.0);\n"
  "  //val = val * val;\n"
  "  vec3 color0 = vec3(val * val * val, val * val, val) * 0.50;\n"
  "  gl_FragColor = vec4(color0, 1.0);\n"
  "}\n"
  "\n";

SHADER_FILES(SKYBOX_TEXTURE, "skybox_texture.vert", "skybox_texture.frag")

shaderSources["skybox_texture.vert"] = 
  "void main(void)\n"
  "{\n"
  "  gl_TexCoord[0].stp = gl_MultiTexCoord0.stp;\n"
  "	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
  "}\n"
  "\n";

shaderSources["star.frag"] = 
  "uniform sampler2D starTex;\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  float alpha = texture2D(starTex, gl_TexCoord[0].st).r;\n"
  "  gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);\n"
  "}\n"
  "\n";

SHADER_FILES(STAR, "star.vert", "star.frag")

shaderSources["star.vert"] = 
  "void main(void)\n"
  "{\n"
  "  gl_TexCoord[0].st = gl_MultiTexCoord0.st;\n"
  "	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
  "}\n"
  "\n";

shaderSources["sun.frag"] = 
  "uniform sampler2D starTex;\n"
  "\n"
  "void main(void)\n"
  "{\n"
  "  float alpha = texture2D(starTex, gl_TexCoord[0].st).r;\n"
  "  alpha += smoothstep(0.7, 0.8, alpha);\n"
  "  gl_FragColor = vec4(1.0, 1.0, 0.8 + 0.2 * alpha, alpha);\n"
  "}\n"
  "\n";

SHADER_FILES(SUN, "sun.vert", "sun.frag")

shaderSources["sun.vert"] = 
  "void main(void)\n"
  "{\n"
  "  gl_TexCoord[0].st = gl_MultiTexCoord0.st;\n"
  "	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
  "}\n"
  "\n";
